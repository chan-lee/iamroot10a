[2014.01.25] review
arch/arm/kernel/setup.c - setup_arch()

1. 저번 시간의 setup_machine_fdt()에 이어 setup_machine_tags() 함수를 봄
    atags_pointer 정보가 담겨있는 address를 기반으로 fdt인가를 확인한후
    fdt가 아닐 경우 setup_machine_tags를 호출한다.
    우리는 atags를 사용하지 않지만 살펴보면 setup_machine_fdt()와 비슷한 구조를
    가지고 있다. machine_desc들로부터 적당한 machine_desc를 찾아내고, atags 정보를
    저장, parse한다.

2. 그 후 setup_machine_fdt() 혹은 tags()로 부터 boot_coomand_line을 cmd_line에 저장한 후,
3. early_param을 파싱하여 earlycon=, console= 옵션을 얻어낸다.
4. 그리고 memory bank를 address순으로 정렬한다. (atags사용시 의미가 있는지는 잘 모르겠다.)

------------------------------------------------------------
[2014.01.25] normal
arch/arm/kernel/setup.c - setup_arch()
    arch/arm/mm/mmu.c - paging_init()
        arch/arm/mm/init.c - bootmem_init()
            arch/arm/mm/init.c - arm_bootmem_free()
                arch/mm/page_alloc.c - free_area_init_node()
                    arch/mm/page_alloc.c - free_area_init_core()

1.                    arch/mm/page_alloc.c - init_currently_empty_zone()
    해당 함수는 zone의 wait_table과 free_list를 할당하고 초기화하는 함수이다.

2.                    arch/mm/page_alloc.c - memmap_init() = memmap_init_zone()
    해당 함수는 page에 zone, nid, page_count, mapcount 등을 설정.
    중간에 set_pageblock_migratetype이란 함수가 나오는데, pageblock의 개념을 잘 모르겠다.
    sparse에서 use_map(section의 시작 포인터)이 pageblock_flag에 저장되었는데, 이것이 왜
    pageblock인지 이유를 알수 없음. use_map이 pageblock인지 조차 잘 모르겠다. TODO


------------------------------------------------------------
[2014.02.15] review
arch/arm/kernel/setup.c - setup_arch()
1.    arch/arm/mm/mmu.c - sanity_check_meminfo()
    sanity_check_meminfo()함수는 membank를 순환하면서 highmem인지 검출하고,
    겹쳐 있는 부분을 나누며, high_memory, memblock_limit등을 설정한다.
    __pa(vmalloc_min - 1) + 1의 경우 vmalloc_min은 high memory의 시작 위치를
    나타내고(760M = 0xEF800000), __pa 함수는 물리 주소로 변환, -1/+1은 잘못된
    변환을 막기 위해서 사용한다. 자세한 내용은 C팀의 후기를 참조하도록 한다.

    - vmalloc_min과 -1/+1에 대한 설명 
    http://www.iamroot.org/xe/index.php?mid=Kernel_10_ARM&page=3&document_srl=185255
    - __pa, __virt_to_phys() 함수에 대한 설명
    http://www.iamroot.org/xe/index.php?mid=Kernel_10_ARM&document_srl=185905

------------------------------------------------------------
[2014.02.15] 후반
arch/arm/kernel/setup.c - setup_arch()
    arch/arm/mm/mmu.c - paging_init()
1.  paging_init()함수 내부 아랫쪽의 zero_page를 flush시키는 곳부터 시작.
    zero_page는 읽기를 위한 page로서 효율을 위해 만들어진 페이지이며,
    쓰기요청이 들어올경우 COW로 작동한다.
    아랫부분에 __flush_dache_page 함수가 있는데, 왜 flush를 하는지와
    내부 구현은 cache에 대한 이해가 부족에 미루기로 한다.

arch/arm/kernel/setup.c - setup_arch()
2.  request_standard_resources에서 iomem_resource와 iomem_resource tree에
    system ram, kernel code, video ram, lp port등을 할당한다.
3.  unflatten_device_tree로 나머지 device  tree를 완성하고, cpu, psci, smp설정을 한다.
    그중 smp_build_mpidr_hash함수는 pass. reverse_crashkernel을 위한 공간도 만들어서
    iomem_resource에 추가한다.
5.  mdesc->init_early() 는 있을듯한데 없다.

------------------------------------------------------------
[2014.02.22] review
setup_arch() - arch/arm/kernel/setup.c 
1.  arm_memblock_init() - arch/arm/mm/init.c
    meminfo로부터 memblock.memory->region을 만들고,
    kernel text/bss, initrd, swapper_pg_dir, dt내의 reverve영역,
    mdesc->reserve영역, DMB contiguos 부분을 memblock.reserve에 추가한다.
    memblock_add -> memblock_add_region -> memblock_double_array() 부분은 
    어느 부분까지 동작하는지 잘 모르겠으므로 패스한다.
    DT level : bank 정보로 부터 meminfo를 만듬
    memblock level : meminfo로 부터 memblock정보를 region으로 채움

    paging_init() - arch/arm/mm/mmu.c
2.      build_mem_type_table() - arch/arm/mm/mmu.c
    cachepolicy와 memtype을 설정한다. 자세한 사항은 다음을 참조하자.
    http://www.iamroot.org/xe/index.php?mid=Kernel_10_ARM&document_srl=185905
 
3. prepare_page_table -preview
    32 bits를 1,2차 table과 page로 나누면, 31~20(1차)/19~12(2차)/11~0(page size)로 나눠지게 된다.
    그러므로 1차table (PGD)의 entries는 4096개가 되고, 2차 table(PTE)의 entries는 256개가 되며,
    page size는 4K가 된다.
    PTE : 256개의 enties는 1K(256 * 4bytes)의 공간을 차지하게 되는데(이때 커버하는 page크기는 1M)
          ARM의 경우 HW의 entry에 dirty bit같은 부가 정보가
          없으므로 linux용 entry가 따로 필요하게 된다. 그러다 보니 pte가 차지하는 공간은
          2K로 늘어나게 된다.
          거기에 pte의 크기가 page의 크기가 되어야 하기 때문에 2쌍이이 들어갈수 있게되고
          linux kernel 입장에서는 총 entries는 512개가 되고 커버하는 page크기는 2M가 된다.
          mmu 입장: 1K, 256 entries, 1M memory cover
          kernel 입장: 4K, 512 enties, 2M memory cover
    PGD : 4096개의 entries가 필요하고 이에 대한 크기는 4096 * 4bytes = 16K가 된다.
          하지만 linux kernel 입장에서는 하나의 PTE는 512개의 entries를 가지게 되고, 결국
          2048개만 필요하게 된다.
          mmu 입장: 16K, 4096 enties, 4G memory cover
          kernel 입장: 16K, 2048 enties, 4G memory cover

------------------------------------------------------------
[2014.02.22] 후반
start_kernel() - init/main.c 
1. 아래와 같은 함수들을 살펴 봄
	mm_init_owner() - kernel/fork.c // init_mm의 owner를 init_task로 함
	mm_init_cpumask() - include/linux/mm_types.h
	setup_command_line() - init/main.c // p.265 참조
	setup_nr_cpu_ids()
2. per_cpu에 대하여 공부함.
    - per_cpu는 언제 사용하는가?
        percpu 의 개념 http://studyfoss.egloos.com/5375570
        percpu 의 사용 http://blog.naver.com/PostView.nhn?blogId=nix102guri&logNo=90098904482
    - thread_safe/ re-entrant 가능한가?
    - thread는 cpu를 옮겨 다니는가?
        work-queue http://studyfoss.egloos.com/5626173

--------------------------------------------------------------------------------
[2014.03.01] review
setup_arch() - arch/arm/kernel/setup.c 
    paging_init - arch/arm/mm/mmu.c
1.      prepare_page_table() - arch/arm/mm/mmu.c
    - PAGE_OFFSET (가상주소0~3G) 까지 pmd를 clear한다.
    - high memory (가상주소3G + 780M)부터 VMALLOC_START까지 pmd를 clear한다.
        왜 VMALLOC_END가 아닌 VMALLOC_START인지는 잘 모르겠다.
2. 의문 : pmd 및 pte는 가상 주소인가? 물리 주소인가?
        
--------------------------------------------------------------------------------
[2014.03.01] 후반
start_kernel() - init/main.c 
	setup_per_cpu_areas() - mm/percpu.c
	    pcpu_embed_first_chunk() - mm/percpu.c
	        pcpu_build_alloc_info() - mm/percpu.c
1. cpu를 group으로 나눈후 각 그룹에 적용했을 때 낭비가 적은 unit per allocs를
    찾는다. alloc과 unit의 상관관계를 알기가 어려워 헤매었다. 다음시간에 마저하도록한다.
    참조 : http://studyfoss.egloos.com/5377666

--------------------------------------------------------------------------------
[2014.03.08] review
setup_arch() - arch/arm/kernel/setup.c 
    paging_init - arch/arm/mm/mmu.c
        low-mem, dma, device, highmem 영역에 대해 mapping을한다.
        create_mapping() 구현 부분은 너무 복잡해서 책을 참조(p.211)하기로 하고
        넘어간다.

1.      map_lowmem() - arch/arm/mm/mmu.c
	    lowmem 영역에 대해 pgd, pud, pmd, pte를 설정한다.
2.      dma_contiguous_remap() - arch/arm/mm/mda-mapping.c
        dma 영역에 대해 다시 mapping
3.      devicemaps_init(mdesc) - arch/arm/mm/mmu.c
        각 장치에 대해 mapping, gap을 메꾸고, pci를 static_vmlist에 등록한다.
	    mapping 끝부분에 있는 pci_reserve_io()는
        PCI 영역을 static_vmlist에 추가하는 함수이다.
	    vmalloc에서 중요한 구조체는 struct vm_struct 와 struct static_vm가
        있는데, staic_vm은 staic_vmlist의 node고 그것들이 각 vm_struct를
        list로 들고 있다.
        io에 의한 pmd_gap을 메꿔주는 자료는 iamroot에 있다. 링크 필요.
4.      kmap_init() - arch/arm/mm/mmu.c
        p.215 TODO  왜 하나의 PMD가 필요한지 잘 모르겠다.

