[2014.01.25] review
arch/arm/kernel/setup.c - setup_arch()

1. 저번 시간의 setup_machine_fdt()에 이어 setup_machine_tags() 함수를 봄
    atags_pointer 정보가 담겨있는 address를 기반으로 fdt인가를 확인한후
    fdt가 아닐 경우 setup_machine_tags를 호출한다.
    우리는 atags를 사용하지 않지만 살펴보면 setup_machine_fdt()와 비슷한 구조를
    가지고 있다. machine_desc들로부터 적당한 machine_desc를 찾아내고, atags 정보를
    저장, parse한다.

2. 그 후 setup_machine_fdt() 혹은 tags()로 부터 boot_coomand_line을 cmd_line에 저장한 후,
3. early_param을 파싱하여 earlycon=, console= 옵션을 얻어낸다.
4. 그리고 memory bank를 address순으로 정렬한다. (atags사용시 의미가 있는지는 잘 모르겠다.)

------------------------------------------------------------
[2014.01.25] normal
arch/arm/kernel/setup.c - setup_arch()
    arch/arm/mm/mmu.c - paging_init()
        arch/arm/mm/init.c - bootmem_init()
            arch/arm/mm/init.c - arm_bootmem_free()
                arch/mm/page_alloc.c - free_area_init_node()
                    arch/mm/page_alloc.c - free_area_init_core()

1.                    arch/mm/page_alloc.c - init_currently_empty_zone()
    해당 함수는 zone의 wait_table과 free_list를 할당하고 초기화하는 함수이다.

2.                    arch/mm/page_alloc.c - memmap_init() = memmap_init_zone()
    해당 함수는 page에 zone, nid, page_count, mapcount 등을 설정.
    중간에 set_pageblock_migratetype이란 함수가 나오는데, pageblock의 개념을 잘 모르겠다.
    sparse에서 use_map(section의 시작 포인터)이 pageblock_flag에 저장되었는데, 이것이 왜
    pageblock인지 이유를 알수 없음. use_map이 pageblock인지 조차 잘 모르겠다. TODO


------------------------------------------------------------
[2014.02.15] review
arch/arm/kernel/setup.c - setup_arch()
1.    arch/arm/mm/mmu.c - sanity_check_meminfo()
    sanity_check_meminfo()함수는 membank를 순환하면서 highmem인지 검출하고,
    겹쳐 있는 부분을 나누며, high_memory, memblock_limit등을 설정한다.
    __pa(vmalloc_min - 1) + 1의 경우 vmalloc_min은 high memory의 시작 위치를
    나타내고(760M = 0xEF800000), __pa 함수는 물리 주소로 변환, -1/+1은 잘못된
    변환을 막기 위해서 사용한다. 자세한 내용은 C팀의 후기를 참조하도록 한다.

    - vmalloc_min과 -1/+1에 대한 설명 
    http://www.iamroot.org/xe/index.php?mid=Kernel_10_ARM&page=3&document_srl=185255
    - __pa, __virt_to_phys() 함수에 대한 설명
    http://www.iamroot.org/xe/index.php?mid=Kernel_10_ARM&document_srl=185905

------------------------------------------------------------
[2014.02.15] 후반
arch/arm/kernel/setup.c - setup_arch()
    arch/arm/mm/mmu.c - paging_init()
1.  paging_init()함수 내부 아랫쪽의 zero_page를 flush시키는 곳부터 시작.
    zero_page는 읽기를 위한 page로서 효율을 위해 만들어진 페이지이며,
    쓰기요청이 들어올경우 COW로 작동한다.
    아랫부분에 __flush_dache_page 함수가 있는데, 왜 flush를 하는지와
    내부 구현은 cache에 대한 이해가 부족에 미루기로 한다.

arch/arm/kernel/setup.c - setup_arch()
2.  request_standard_resources에서 iomem_resource와 iomem_resource tree에
    system ram, kernel code, video ram, lp port등을 할당한다.
3.  unflatten_device_tree로 나머지 device  tree를 완성하고, cpu, psci, smp설정을 한다.
    그중 smp_build_mpidr_hash함수는 pass. reverse_crashkernel을 위한 공간도 만들어서
    iomem_resource에 추가한다.
5.  mdesc->init_early() 는 있을듯한데 없다.

------------------------------------------------------------
[2014.02.22] review
setup_arch() - arch/arm/kernel/setup.c 
1.  arm_memblock_init() - arch/arm/mm/init.c
    meminfo로부터 memblock.memory->region을 만들고,
    kernel text/bss, initrd, swapper_pg_dir, dt내의 reverve영역,
    mdesc->reserve영역, DMB contiguos 부분을 memblock.reserve에 추가한다.
    memblock_add -> memblock_add_region -> memblock_double_array() 부분은 
    어느 부분까지 동작하는지 잘 모르겠으므로 패스한다.
    DT level : bank 정보로 부터 meminfo를 만듬
    memblock level : meminfo로 부터 memblock정보를 region으로 채움

    paging_init() - arch/arm/mm/mmu.c
2.      build_mem_type_table() - arch/arm/mm/mmu.c
    cachepolicy와 memtype을 설정한다. 자세한 사항은 다음을 참조하자.
    http://www.iamroot.org/xe/index.php?mid=Kernel_10_ARM&document_srl=185905
 
3. prepare_page_table -preview
    PTE : MMU는 하나의 page table은 1K의 크기를 가지고 있고, 이는 256개(1K / 4bytes)의
          entry들이 있게 된다.(이때 커버하는 page크기는 1M)
          하지만 ARM의 경우 HW의 entry에 dirty bit같은 부가 정보가
          없으므로 linux용 entry가 따로 필요하게 된다. 그러다 보니 pte 크기는 2K로 늘어나게 된다.
          거기에 pte의 크기가 page의 크기가 되어야 하기 때문에 2쌍이이 들어갈수 있게되고
          linux kernel 입장에서는 총 entries는 512개가 되고 커버하는 page크기는 2M가 된다.
          mmu 입장: 1K, 256 entries, 1M memory cover
          kernel 입장: 4K, 512 enties, 2M memory cover
    PGD : MMU의 입장에서는 PTE는 1M(256개)를 커버하므로, 4G를 커버하기 위해서는 4096개의 entry가
          필요하게되고 이의 크기는 4096 * 4bytes = 16K가 된다. 하지만 linux kernel
          입장에서는 PTE는 512개의 entry이게 되고 4G를 커버하기 위한 entry는 2048개가 된다.
          mmu 입장: 16K, 4096 enties, 4G memory cover
          kernel 입장: 16K, 2048 enties, 4G memory cover

